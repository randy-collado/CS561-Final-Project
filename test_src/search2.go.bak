package main

import (
	"math/rand"
	"runtime"
	"time"
)

type Node struct {
	key    int
	ch     []*Node
	values []int
}

type Task struct {
	node    *Node
	srhType int
	depth   int
	key     int
	// other args
}

var found bool
var terminated bool

func worker(task_ch chan Task, flag_ch chan bool, num int) {
	println("Worker starts", num)
	for {
		if found || terminated {
			break
		}
		select {
		case task := <-task_ch:
			println("Receive Task", task.node.key)
			node := task.node
			if node == nil || task.depth <= 0 {
				return
			}
			if node.key == task.key {
				found = true
				flag_ch <- true
				return
			}
			if task.srhType == 1 { // Bfs
				for _, node := range node.ch {
					if node.key == task.key {
						found = true
						flag_ch <- true
						return
					}
					task_ch <- Task{node, 1, 1, task.key}
					println("Send Task", node.key)
				}
			} // else if other searching type
		case <-time.After(time.Microsecond * 50):
		}
	}
	println("Worker ends", num)
}

func gen_tree(curNode *Node, curDepth int) {
	if curDepth == 0 {
		return
	}
	for i := 0; i < rand.Intn(10); i++ {
		tmpNode := Node{rand.Intn(20), nil, nil}
		curNode.ch = append(curNode.ch, &tmpNode)
		gen_tree(&tmpNode, curDepth-1)
	}
}

func main() {
	key := 15
	found = false
	root := Node{-1, nil, nil}
	maxDepth := 8
	gen_tree(&root, maxDepth)

	task_ch := make(chan Task, 50)
	flag_ch := make(chan bool, 1)

	cpus := runtime.NumCPU()
	runtime.GOMAXPROCS(cpus)

	worker_num := cpus - 1

	for i := 0; i < worker_num; i++ {
		go worker(task_ch, flag_ch, i)
	}

	task_ch <- Task{&root, 1, 1, key}

	timeOutCnt := 0
	for {
		if found {
			println("Found")
			break
		}
		if timeOutCnt > 5 {
			println("Not found")
			break
		}
		select {
		case <-flag_ch:
		case <-time.After(time.Second):
			timeOutCnt += 1
		}
	}
}
